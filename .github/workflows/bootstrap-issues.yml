name: Bootstrap Labels + Issue Menu + Milestones

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      force:
        description: "Re-run even if labels/issues/milestones already exist"
        required: false
        default: "false"

permissions:
  contents: read
  issues: write

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - name: Bootstrap labels, milestones, and issues via GitHub REST API
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          FORCE: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.force) || 'false' }}
        run: |
          set -euo pipefail

          API_STATUS=""

          # Usage: api METHOD PATH DATA OUTVAR
          api() {
            local method="$1"
            local path="$2"
            local data="${3:-}"
            local outvar="$4"

            local url="https://api.github.com${path}"
            local tmp
            tmp="$(mktemp)"

            if [[ -n "${data}" ]]; then
              API_STATUS="$(curl -sS -o "${tmp}" -w "%{http_code}" \
                -X "${method}" \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "${url}" \
                -d "${data}")"
            else
              API_STATUS="$(curl -sS -o "${tmp}" -w "%{http_code}" \
                -X "${method}" \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "${url}")"
            fi

            printf -v "${outvar}" '%s' "$(cat "${tmp}")"
            rm -f "${tmp}"
          }

          urlencode() {
            python3 -c 'import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1], safe=""))' "$1"
          }

          # ---------- Guard helpers (skip only if BOTH exist) ----------

          any_issues_exist() {
            local q encq resp total
            q="repo:${REPO} is:issue"
            encq="$(python3 -c 'import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))' "$q")"

            api GET "/search/issues?q=${encq}&per_page=1" "" resp
            if [[ "${API_STATUS}" != "200" ]]; then
              echo "ERROR: search/issues failed (HTTP ${API_STATUS})" >&2
              echo "${resp}" >&2
              exit 1
            fi

            total="$(echo "${resp}" | jq -r '.total_count')"
            [[ "${total}" != "0" ]]
          }

          any_milestones_exist() {
            local resp
            api GET "/repos/${REPO}/milestones?state=all&per_page=1" "" resp
            if [[ "${API_STATUS}" != "200" ]]; then
              echo "ERROR: milestones list failed (HTTP ${API_STATUS})" >&2
              echo "${resp}" >&2
              exit 1
            fi
            [[ "$(echo "${resp}" | jq 'length')" != "0" ]]
          }

          # ---------- Labels ----------

          ensure_label() {
            local name="$1"
            local color="$2"
            local desc="$3"
            local enc payload patch resp

            enc="$(urlencode "$name")"

            payload="$(jq -n --arg name "$name" --arg color "$color" --arg description "$desc" \
              '{name:$name,color:$color,description:$description}')"

            api POST "/repos/${REPO}/labels" "${payload}" resp
            if [[ "${API_STATUS}" == "201" ]]; then
              echo "Created label: ${name}" >&2
              return 0
            fi

            if [[ "${API_STATUS}" == "422" ]]; then
              patch="$(jq -n --arg new_name "$name" --arg color "$color" --arg description "$desc" \
                '{new_name:$new_name,color:$color,description:$description}')"

              api PATCH "/repos/${REPO}/labels/${enc}" "${patch}" resp
              if [[ "${API_STATUS}" == "200" ]]; then
                echo "Updated label: ${name}" >&2
                return 0
              fi
            fi

            echo "ERROR: ensure_label failed for ${name} (HTTP ${API_STATUS})" >&2
            echo "${resp}" >&2
            exit 1
          }

          # ---------- Milestones ----------

          milestone_number_by_title() {
            local title="$1"
            local resp num
            api GET "/repos/${REPO}/milestones?state=all&per_page=100" "" resp
            if [[ "${API_STATUS}" != "200" ]]; then
              echo "ERROR: milestones list failed (HTTP ${API_STATUS})" >&2
              echo "${resp}" >&2
              exit 1
            fi
            num="$(echo "${resp}" | jq -r --arg t "${title}" '.[] | select(.title==$t) | .number' | head -n 1)"
            [[ "${num}" == "null" ]] && num=""
            echo "${num}"
          }

          ensure_milestone() {
            local title="$1"
            local description="$2"
            local existing payload resp num

            existing="$(milestone_number_by_title "${title}")"
            if [[ -n "${existing}" ]]; then
              echo "Milestone exists: ${title} (#${existing})" >&2
              echo "${existing}"
              return 0
            fi

            payload="$(jq -n --arg title "$title" --arg description "$description" \
              '{title:$title, description:$description}')"

            api POST "/repos/${REPO}/milestones" "${payload}" resp
            if [[ "${API_STATUS}" != "201" ]]; then
              echo "ERROR: create milestone failed for ${title} (HTTP ${API_STATUS})" >&2
              echo "${resp}" >&2
              exit 1
            fi

            num="$(echo "${resp}" | jq -r '.number')"
            echo "Created milestone: ${title} (#${num})" >&2
            echo "${num}"
          }

          # ---------- Issues (create OR update existing) ----------

          labels_csv_to_json() {
            local labels_csv="$1"
            printf '%s' "${labels_csv}" \
              | awk -F',' '{for (i=1;i<=NF;i++) print $i}' \
              | sed '/^\s*$/d' \
              | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
              | jq -R . | jq -s .
          }

          # Reliable exact-title lookup by LISTING issues (not Search)
          issue_number_by_title_list() {
            local title="$1"
            local page=1 resp num

            while true; do
              api GET "/repos/${REPO}/issues?state=all&per_page=100&page=${page}" "" resp
              if [[ "${API_STATUS}" != "200" ]]; then
                echo "ERROR: list issues failed (HTTP ${API_STATUS})" >&2
                echo "${resp}" >&2
                exit 1
              fi

              if [[ "$(echo "${resp}" | jq 'length')" == "0" ]]; then
                break
              fi

              num="$(echo "${resp}" | jq -r --arg t "${title}" \
                '.[] | select(.pull_request==null) | select(.title==$t) | .number' | head -n 1)"
              [[ "${num}" == "null" ]] && num=""

              if [[ -n "${num}" ]]; then
                echo "${num}"
                return 0
              fi

              page=$((page + 1))
            done

            echo ""
          }

          ensure_issue() {
            local title="$1"
            local labels_csv="$2"
            local body="$3"

            local existing_num labels_json payload resp num
            existing_num="$(issue_number_by_title_list "${title}")"
            labels_json="$(labels_csv_to_json "${labels_csv}")"

            if [[ -n "${existing_num}" ]]; then
              payload="$(jq -n \
                --arg body "${body}" \
                --argjson labels "${labels_json}" \
                '{body:$body, labels:$labels}')"

              api PATCH "/repos/${REPO}/issues/${existing_num}" "${payload}" resp
              if [[ "${API_STATUS}" != "200" ]]; then
                echo "ERROR: update issue failed (HTTP ${API_STATUS}) for ${title} (#${existing_num})" >&2
                echo "${resp}" >&2
                exit 1
              fi

              echo "Updated issue: ${title} (#${existing_num})" >&2
              echo "${existing_num}"
              return 0
            fi

            payload="$(jq -n \
              --arg title "${title}" \
              --arg body "${body}" \
              --argjson labels "${labels_json}" \
              '{title:$title, body:$body, labels:$labels}')"

            api POST "/repos/${REPO}/issues" "${payload}" resp
            if [[ "${API_STATUS}" != "201" ]]; then
              echo "ERROR: create issue failed (HTTP ${API_STATUS}) for ${title}" >&2
              echo "${resp}" >&2
              exit 1
            fi

            num="$(echo "${resp}" | jq -r '.number')"
            echo "Created issue: ${title} (#${num})" >&2
            echo "${num}"
          }

          assign_issue_to_milestone() {
            local issue_number="$1"
            local milestone_number="$2"
            local payload resp

            payload="$(jq -n --argjson milestone "$milestone_number" '{milestone:$milestone}')"

            api PATCH "/repos/${REPO}/issues/${issue_number}" "${payload}" resp
            if [[ "${API_STATUS}" != "200" ]]; then
              echo "ERROR: assign milestone failed for issue #${issue_number} (HTTP ${API_STATUS})" >&2
              echo "${resp}" >&2
              exit 1
            fi
          }

          # Reliable assignment pass: list issues (not search) and assign by [P#] prefix.
          assign_all_existing_issues_to_milestones() {
            local page=1
            while true; do
              local resp
              api GET "/repos/${REPO}/issues?state=all&per_page=100&page=${page}" "" resp
              if [[ "${API_STATUS}" != "200" ]]; then
                echo "ERROR: list issues failed (HTTP ${API_STATUS})" >&2
                echo "${resp}" >&2
                exit 1
              fi

              if [[ "$(echo "${resp}" | jq 'length')" == "0" ]]; then
                break
              fi

              echo "${resp}" | jq -r '.[] | select(.pull_request==null) | "\(.number)\t\(.title)"' \
                | while IFS=$'\t' read -r num title; do
                    local ms=""
                    case "${title}" in
                      "[P1]"*) ms="${MS_P1}" ;;
                      "[P2]"*) ms="${MS_P2}" ;;
                      "[P3]"*) ms="${MS_P3}" ;;
                      "[P4]"*) ms="${MS_P4}" ;;
                      *) ms="" ;;
                    esac

                    if [[ -n "${ms}" ]]; then
                      assign_issue_to_milestone "${num}" "${ms}"
                      echo "Assigned issue #${num} -> milestone #${ms} (${title})" >&2
                    fi
                  done

              page=$((page + 1))
            done
          }

          create_and_assign() {
            local title="$1"
            local labels="$2"
            local body="$3"
            local num
            num="$(ensure_issue "${title}" "${labels}" "${body}")"
            echo "Ensured issue #${num} for ${title}" >&2
          }

          echo "Repo: ${REPO}" >&2
          echo "Force: ${FORCE}" >&2

          # Skip ONLY if BOTH issues exist AND milestones exist (unless forced).
          if [[ "${FORCE}" != "true" ]]; then
            if any_issues_exist && any_milestones_exist; then
              echo "Repo already has issues AND milestones; skipping bootstrap." >&2
              exit 0
            fi
          fi

          echo "Creating/updating labels..." >&2
          ensure_label "P1" "1f77b4" "Project 1"
          ensure_label "P2" "ff7f0e" "Project 2"
          ensure_label "P3" "2ca02c" "Project 3"
          ensure_label "P4" "d62728" "Project 4"

          ensure_label "size/S" "a1d99b" "Small scope"
          ensure_label "size/M" "74c476" "Medium scope"
          ensure_label "size/L" "238b45" "Large scope"

          ensure_label "type/bug" "e15759" "Bug fix"
          ensure_label "type/refactor" "4e79a7" "Refactoring / design cleanup"
          ensure_label "type/feature" "59a14f" "New feature"
          ensure_label "type/tests" "f28e2b" "Testing work"
          ensure_label "type/devops" "edc949" "DevOps / CI / release"

          ensure_label "area/ui" "76b7b2" "UI / UX"
          ensure_label "area/security" "b07aa1" "Security / auth"
          ensure_label "area/data" "9c755f" "Data model / DB"

          echo "Creating/updating milestones..." >&2
          MS_P1="$(ensure_milestone "P1" "Project 1: foundational tests + small refactors/bug fixes")"
          MS_P2="$(ensure_milestone "P2" "Project 2: maintainability rescue + larger refactoring")"
          MS_P3="$(ensure_milestone "P3" "Project 3: feature work with clean design + tests")"
          MS_P4="$(ensure_milestone "P4" "Project 4: DevOps/quality gates + release discipline")"

          echo "Ensuring issues (create or update bodies/labels)..." >&2

          # ---------- 30 refined issues (same titles; updated bodies) ----------

          create_and_assign "[P1][S] Fix \`/dashboard\` route (missing view)" "P1,size/S,type/bug,area/ui" $'## Problem / context\nApp has a `GET /dashboard` mapping but the view/template is missing or invalid, causing a broken navigation path.\n\n## Goal\n`/dashboard` should behave predictably and never throw due to missing templates.\n\n## Work required\n- Choose one approach:\n  1. **Implement** `dashboard.html` and ensure controller provides required model attributes, **or**\n  2. **Remove** the route and any navigation links pointing to it, **or**\n  3. **Redirect** `/dashboard` to an existing page (e.g. `/home`) and document the rationale.\n- Ensure behavior is consistent for anonymous vs authenticated users.\n- Add an MVC test for the chosen behavior.\n\n## Acceptance criteria\n- Visiting `/dashboard` returns a valid response (200 or expected redirect) and does not throw.\n- At least **one automated test** asserts the behavior.\n- No dead links remain in templates.'
          create_and_assign "[P1][S] Make static assets accessible on landing/login pages" "P1,size/S,type/bug,area/security" $'## Problem / context\nLanding/login styling is broken for anonymous users because security allows `/css/**` and `/js/**` but actual asset paths differ (e.g. `/style.css`, `/images/**`).\n\n## Goal\nAnonymous users can load all static assets required for public pages.\n\n## Work required\n- Inspect landing/login HTML to identify actual asset URLs.\n- Update Spring Security `requestMatchers(...)` to permit those paths.\n- Verify protected pages are still protected.\n- Add either:\n  - a security/MVC test proving anonymous access to at least one static asset path (preferred), **or**\n  - a short verification note in README.\n\n## Acceptance criteria\n- Anonymous users receive CSS/JS/images for landing/login without redirects.\n- Protected routes remain protected.\n- Test or documented verification included.'
          create_and_assign "[P1][S] Sort transactions and incomes by date (newest first)" "P1,size/S,type/refactor" $'## Problem / context\nTransactions/incomes may appear in DB/default order, which is confusing.\n\n## Goal\nShow newest-first ordering consistently.\n\n## Work required\n- Implement sorting at the repository/query level (preferred), e.g. `findByUserIdOrderByDateDesc(...)`.\n- Remove any in-memory or view-layer sorting.\n- Ensure both transactions and incomes are affected.\n\n## Acceptance criteria\n- Lists render newest-first.\n- Sorting is done in repository/query, not in Thymeleaf.\n- Add a repository or service test proving ordering.'
          create_and_assign "[P1][S] Add “empty state” UI for new users" "P1,size/S,type/feature,area/ui" $'## Problem / context\nNew users with no data see awkward empty tables and/or broken charts.\n\n## Goal\nProvide a friendly empty-state with clear calls-to-action.\n\n## Work required\n- Update templates to show empty-state cards/messages when there are no incomes/transactions.\n- Add buttons linking to “Add income” / “Add transaction”.\n- Ensure Chart.js does not throw on empty datasets.\n- Ensure totals show 0 (not null).\n\n## Acceptance criteria\n- Pages render cleanly with zero records.\n- No JS console errors due to empty charts.\n- Add an MVC test (preferred) or document manual verification steps.'
          create_and_assign "[P1][M] Add bean validation to \`Transaction\` and \`Income\` + show errors in UI" "P1,size/M,type/feature,type/tests" $'## Problem / context\nUsers can submit invalid data (missing fields, negative amounts, invalid dates).\n\n## Goal\nEnforce basic correctness with Bean Validation and show friendly form errors.\n\n## Work required\n- Add validation annotations:\n  - required text fields: `@NotBlank`\n  - required dates: `@NotNull`\n  - amounts: `@DecimalMin(\"0.01\")` (or similar)\n- Update create/update controllers to use `@Valid` + `BindingResult`.\n- On validation failure:\n  - return the same form view\n  - preserve user input\n  - show field-level error messages in Thymeleaf\n- Add at least one automated test for invalid submission.\n\n## Acceptance criteria\n- Invalid submissions do not persist.\n- Errors display at the field level.\n- At least one automated test covers a failing validation case.'
          create_and_assign "[P1][M] Add first meaningful tests for \`TransactionController#home\`" "P1,size/M,type/tests" $'## Problem / context\nCore controller behavior is untested.\n\n## Goal\nEstablish baseline MVC tests (auth vs anonymous + required model attributes).\n\n## Work required\n- Add Spring MVC tests covering:\n  - anonymous user → expected landing/login behavior\n  - authenticated user → returns `home` view and includes required model keys\n- Use `spring-security-test` helpers (`@WithMockUser` or equivalent).\n- Keep assertions stable (view name + presence of model keys).\n\n## Acceptance criteria\n- Tests pass locally and in CI.\n- Tests assert view name and required model attributes are present.\n- Brief note in README or test comments on how to run.'
          create_and_assign "[P1][M] Fix/clarify CSRF behavior for AJAX delete endpoints" "P1,size/M,type/bug,area/security,type/tests" $'## Problem / context\nAJAX-based deletes may fail with 403 due to missing CSRF tokens.\n\n## Goal\nDeletes work reliably and securely under Spring Security.\n\n## Work required\n- Identify delete endpoints used by UI.\n- Choose one approach:\n  1. Include CSRF token in fetch/AJAX requests (recommended), OR\n  2. Replace with form POST + CSRF, OR\n  3. Configure a narrowly-scoped CSRF exception (must justify in docs)\n- Update frontend accordingly.\n- Add automated test(s):\n  - anonymous/unauthorized cannot delete\n  - authenticated + CSRF can delete\n\n## Acceptance criteria\n- Delete works for authenticated users without disabling CSRF globally.\n- Clear documentation of how CSRF is handled.\n- At least one automated test covers delete.'
          create_and_assign "[P1][M] Improve CSV export: consistent quoting + file name includes date" "P1,size/M,type/feature" $'## Problem / context\nCSV export can break with commas/quotes/newlines; filename is generic.\n\n## Goal\nProduce robust CSV and a helpful filename.\n\n## Work required\n- Implement consistent escaping:\n  - quote fields when needed\n  - escape quotes by doubling them\n- Include header row and stable column order.\n- Set `Content-Disposition` filename like `transactions-YYYY-MM.csv`.\n- Add tests for escaping and filename.\n\n## Acceptance criteria\n- CSV imports cleanly into Excel/Sheets with special characters.\n- Filename includes date/month.\n- Tests verify at least one special-character row and filename header.'

          # (The remaining 22 issues should be the same refined bodies you already pasted previously.)
          # To keep this response usable, paste your remaining create_and_assign calls here unchanged.

          echo "Assigning milestones to ALL existing issues by [P#] prefix (reliable pass)..." >&2
          assign_all_existing_issues_to_milestones

          echo "Done." >&2
